// automatically generated by rust-bindgen, with some modifications
#![allow(dead_code)]
extern crate libc;
pub mod common;
use libc::{c_int, c_double, c_char, c_uint};
use common::Struct_feature_node;
use std::mem;


#[repr(C)]
#[derive(Copy)]
pub struct Struct_problem {
    pub l: c_int, // number of examples
    pub n: c_int, // max index
    pub y: *const c_double,
    pub x: *const *const Struct_feature_node, // array of pointers
    pub bias: c_double,
}
impl Clone for Struct_problem {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for Struct_problem {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}

// pub type Enum_Unnamed1 = c_uint;
pub const L2R_LR: c_uint = 0;
pub const L2R_L2LOSS_SVC_DUAL: c_uint = 1;
pub const L2R_L2LOSS_SVC: c_uint = 2;
pub const L2R_L1LOSS_SVC_DUAL: c_uint = 3;
pub const MCSVM_CS: c_uint = 4;
pub const L1R_L2LOSS_SVC: c_uint = 5;
pub const L1R_LR: c_uint = 6;
pub const L2R_LR_DUAL: c_uint = 7;
pub const L2R_L2LOSS_SVR: c_uint = 11;
pub const L2R_L2LOSS_SVR_DUAL: c_uint = 12;
pub const L2R_L1LOSS_SVR_DUAL: c_uint = 13;

#[repr(C)]
#[derive(Copy)]
#[allow(non_snake_case)]
pub struct Struct_parameter {
    pub solver_type: c_uint,
    pub eps: c_double,
    pub C: c_double,
    pub nr_weight: c_int,
    pub weight_label: *const c_int,
    pub weight: *const c_double,
    pub p: c_double,
    pub init_sol: *const c_double,
}
impl Clone for Struct_parameter {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for Struct_parameter {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_model {
    pub param: Struct_parameter,
    pub nr_class: c_int,
    pub nr_feature: c_int,
    pub w: *const c_double,
    pub label: *const c_int,
    pub bias: c_double,
}
impl Clone for Struct_model {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for Struct_model {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}

#[link(name = "linear", kind = "static")]
extern "C" {
    pub fn train(prob: *const Struct_problem,
                 param: *const Struct_parameter)
                 -> *const Struct_model;
    pub fn cross_validation(prob: *const Struct_problem,
                            param: *const Struct_parameter,
                            nr_fold: c_int,
                            target: *const c_double)
                            -> ();
    pub fn find_parameter_C(prob: *const Struct_problem,
                            param: *const Struct_parameter,
                            nr_fold: c_int,
                            start_C: c_double,
                            max_C: c_double,
                            best_C: *const c_double,
                            best_rate: *const c_double)
                            -> ();
    pub fn predict_values(model_: *const Struct_model,
                          x: *const Struct_feature_node,
                          dec_values: *const c_double)
                          -> c_double;
    pub fn predict(model_: *const Struct_model, x: *const Struct_feature_node) -> c_double;
    pub fn predict_probability(model_: *const Struct_model,
                               x: *const Struct_feature_node,
                               prob_estimates: *const c_double)
                               -> c_double;
    pub fn save_model(model_file_name: *const c_char, model_: *const Struct_model) -> c_int;
    pub fn load_model(model_file_name: *const c_char) -> *const Struct_model;
    pub fn get_nr_feature(model_: *const Struct_model) -> c_int;
    pub fn get_nr_class(model_: *const Struct_model) -> c_int;
    pub fn get_labels(model_: *const Struct_model, label: *const c_int) -> ();
    pub fn get_decfun_coef(model_: *const Struct_model,
                           feat_idx: c_int,
                           label_idx: c_int)
                           -> c_double;
    pub fn get_decfun_bias(model_: *const Struct_model, label_idx: c_int) -> c_double;
    pub fn free_model_content(model_ptr: *const Struct_model) -> ();
    pub fn free_and_destroy_model(model_ptr_ptr: *const *const Struct_model) -> ();
    pub fn destroy_param(param: *mut Struct_parameter) -> ();
    pub fn check_parameter(prob: *const Struct_problem,
                           param: *const Struct_parameter)
                           -> *const c_char;
    pub fn check_probability_model(model: *const Struct_model) -> c_int;
    pub fn check_regression_model(model: *const Struct_model) -> c_int;
}



#[cfg(test)]
mod tests {
    use super::*;
    extern crate rand;
    use self::rand::{thread_rng, Rng};
    use std::{ptr, slice};
    use std::marker::PhantomData;
    // use common;

    fn random_floats(d: usize) -> Vec<f64> {
        let mut rng = thread_rng();
        rng.gen_iter::<f64>().take(d).collect::<Vec<f64>>()
    }

    pub struct Problem {
        pub num_examples: i32,
        pub max_index: i32,
        pub labels: Vec<f64>,
        pub examples: Vec<Vec<common::Struct_feature_node>>,
        pub example_ptrs: Vec<*const common::Struct_feature_node>,
        pub bias: f64,
        pub raw: Struct_problem,
    }


    impl Problem {
        pub fn from_training_data(xs: &Vec<Vec<f64>>, ys: &Vec<f64>) -> Problem {
            let (examples, max_index) = make_sparse_matrix(xs);
            let example_ptrs = vec_to_ptrs(&examples).vec;
            let labels = ys.clone();
            let raw = Struct_problem {
                l: ys.len() as i32,
                n: max_index,
                y: labels.as_ptr(),
                x: (&example_ptrs[..]).as_ptr(),
                bias: -1.0,
            };
            Problem {
                num_examples: ys.len() as i32,
                max_index: max_index,
                labels: labels,
                examples: examples,
                example_ptrs: example_ptrs,
                bias: -1.0,
                raw: raw,
            }
        }
    }


    #[derive(Default, Debug)]
    #[allow(non_snake_case)] // to better match liblinear names
    pub struct Parameters {
        pub solver_type: u32,
        pub eps: f64,
        pub C: f64,
        pub nr_weight: i32,
        pub weight_label: Option<Vec<i32>>,
        pub weight: Option<Vec<f64>>,
        pub p: f64,
    }

    impl Parameters {
        #[allow(dead_code)]
        fn from_raw(mut param: Struct_parameter) -> Parameters {

            let mut safe_params: Parameters = Parameters::default();
            unsafe {
                safe_params.solver_type = param.solver_type;
                safe_params.eps = param.eps;
                safe_params.C = param.C;
                safe_params.nr_weight = param.nr_weight;
                // TODO weight_label, weight could be null
                if !param.weight_label.is_null() {
                    safe_params.weight_label =
                        Some(slice::from_raw_parts(param.weight_label,
                                                   safe_params.nr_weight as usize)
                                 .to_vec());
                } else {
                    safe_params.weight_label = None;
                }
                if !param.weight.is_null() {
                    safe_params.weight =
                        Some(slice::from_raw_parts(param.weight, safe_params.nr_weight as usize)
                                 .to_vec());
                } else {
                    safe_params.weight = None;
                }
                safe_params.p = param.p;
                destroy_param(&mut param as *mut Struct_parameter);
            }
            safe_params
        }
    }

    #[test]
    fn train_model() {
        let num_examples = 10;
        let train_data = (0..num_examples)
                             .map(|_| random_floats(8))
                             .collect::<Vec<Vec<f64>>>();
        let mut labels = Vec::with_capacity(num_examples);
        for i in 0..num_examples {
            if i % 2 == 0 {
                labels.push(1.0);
            } else {
                // TODO: should these be 0.0 or -1.0???
                labels.push(0.0);
            }
        }
        let problem = Problem::from_training_data(&train_data, &labels);
        let params = Struct_parameter {
            solver_type: L2R_LR,
            eps: 0.0001,
            C: 1.0f64,
            nr_weight: 0,
            weight_label: ptr::null_mut(),
            weight: ptr::null_mut(),
            p: 0.1,
            init_sol: ptr::null_mut(),
        };
        unsafe {
            let model = train(&problem.raw as *const Struct_problem,
                              &params as *const Struct_parameter);

            // let nr_class = (*model).nr_class;
            // let nr_feature = (*model).nr_feature;
            let w = slice::from_raw_parts((*model).w, (*model).nr_feature as usize).to_vec();
            // TODO: this will panic, just want to see what w is for now
            assert_eq!(w, vec![1.2; 10]);
            free_and_destroy_model(&model as *const *const Struct_model);
        }

    }





    pub struct PtrVec<'a, T: 'a> {
        pub vec: Vec<*const T>,
        phantom: PhantomData<&'a Vec<T>>,
    }

    // TODO figure out how to use lifetimes
    pub fn vec_to_ptrs<'a, T>(examples: &'a Vec<Vec<T>>) -> PtrVec<'a, T> {

        // let all_x_vec: Vec<*mut Struct_feature_node> = Vec::new();
        let mut first_x_vec: Vec<*const T> = Vec::with_capacity(examples.len());

        for i in 0..examples.len() {
            first_x_vec.push((&examples[i][..]).as_ptr());
        }
        PtrVec {
            vec: first_x_vec,
            phantom: PhantomData,
        }
    }

    pub fn make_sparse_matrix(xs: &Vec<Vec<f64>>) -> (Vec<Vec<common::Struct_feature_node>>, i32) {

        let mut examples: Vec<Vec<common::Struct_feature_node>> = Vec::with_capacity(xs.len());

        let mut max_index = 1;
        for example in xs {
            let mut features: Vec<common::Struct_feature_node> = Vec::new();
            let mut idx = 1; // liblinear is 1-based indexing
            for f in example.iter() {
                if *f != 0.0 {
                    if idx > max_index {
                        max_index = idx;
                    }
                    let f_node = common::Struct_feature_node {
                        index: idx,
                        value: *f,
                    };
                    features.push(f_node);
                }
                idx += 1;
            }
            features.push(common::Struct_feature_node {
                index: -1,
                value: 0.0,
            }); // -1 indicates end of feature vector
            examples.push(features);
        }
        (examples, max_index)
    }
}
